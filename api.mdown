### PAKE REST API

This is the API that is exposed by your mirrors and
other people aliens (in this case *mirror* and *alien* are used as
parts of PAKE terminology).

API is created by structure of directories and does not require any
exotic software to run (no Python, Perl, Ruby or even PHP) - just a
server to provide access to them (simple nginx or Apache).

----

### Terminology

PAKE uses some terminology to describe its repositories, mirrors etc.
It is explained below.

* `nest`    - directory (`.pakenest`) located in a directory of a project (similar to `.git`),
* `node`    - directory (`.pakenode`) located in home directory (`~`) of a user - used to generate mirrors and
manage packages,
* `mirror`  - place on the net which 1) exposes PAKE alien API and 2) is generated from your node,
* `alien`   - place on the net which 1) exposes PAKE alien API and 2) is not generated from your node,


----

### Alien API structure

Here are shown paths that can be used to access various information on an alien or
(mirror if you are interaction with alien originating from your node).
`:foo`-like strings describe variable endpoints.

    ROOT = http://pake.example.com

    # obligatory part of the API (net expanding alien a.k.a. NEA)
    ROOT/meta.json
    ROOT/mirrors.json
    ROOT/alines.json
    ROOT/packages.json

    # API exposed by aliens which provide downloadable packages
    ROOT/packages/:name/versions.json
    ROOT/packages/:name/versions/:version/meta.json
    ROOT/packages/:name/versions/:version/dependencies.json
    ROOT/packages/:name/versions/:version/build.tar.xz
    ROOT/packages/:name/versions/:version/signature.asc [**not implemented**]

    # optional part of the API (caching is done as a last-hope mechanism when trying to obtain
    # a package whose alien of origin is no longer available and all its mirror are down)
    ROOT/cached.json
    ROOT/cached/{name}-{version}.tar.xz
    ROOT/cached/{name}-{version}.asc


Files from `ROOT/packages/:name/:version:/build.tar.xz` are saved as `{:name}-{:version}.tar.xz` files in
`~/.pakenode/cached/` directory.

----

### Node API structure

Here is shown API of the node. Arrows (`->`) show that a part of alien API is generated from such and such file.
If no arrow is located after the file it means that the file is sent to the net.

    ROOT = ~/.pakenode

    ROOT/aliens.json
    ROOT/meta.json
    ROOT/nests.json -> packages.json
    ROOT/pushers.json -> mirrors.json

    # optional files that may be sent to the net
    ROOT/cached.json
    ROOT/cached/

    # these files and directories are not sent to the net
    ROOT/installing/
    ROOT/db/pkgs.json
    ROOT/db/transactions/pkgs/:name/remove.fsrl
    ROOT/db/transactions/prepared/:hash.transaction

    # these are not sent to the net and
    # may be not even implemented
    ROOT/db/keys/
    ROOT/db/keys/local/
    ROOT/db/keys/imported/

> `ROOT/db/keys` may be not even needed as keys should be imported from and to global `~/.gnupg` directory.

`packages.json` must be generated from `nests.json` before pushing, otherwise your node will
contain empty package list.

    pake node nests --gen-pkg-list

`mirrors.json` must be generated from `pushers.json` beforepushing, otherwise your node will
contain empty mirrors list. You can use `--pretty` option to enable pretty formatting.

    pake mirrors --gen-list [--pretty]

----

### Nest API structure

Here is shown API exposed by the nest.

    ROOT = ./.pakenest

    ROOT/meta.json
    ROOT/dependencies.json
    ROOT/files.json
    ROOT/install.fsrl
    ROOT/update.fsrl
    ROOT/remove.fsrl
    ROOT/versions.json
    ROOT/versions/:version/meta.json
    ROOT/versions/:version/dependencies.json
    ROOT/versions/:version/build.tar.xz


`build.tar.xz` contains:

* files and directories listed in `files.json`,
* `meta.json` and `dependencies.json` files,
* `install.fsrl`, `update.fsrl` and `remove.fsrl` files,

&nbsp;

#### Dependencies

Dependencies are packages which must be installed with the selected package to ensure its
proper working. `dependencies.json` is a file containing a list of these packages.
Each dependency (or *dep*) is a dictionary containing few pieces of data:

* `name`        - name of the package,
* `origin`      - URL of the origin of the package,
* `min-version` - minimal version of the dependency that must installed,
* `max-version` - maximal version of the dependency that should be installed,

List of mirrors of the origin are generated dynamically by looking up origin URL in
`aliens.json` file.

Each dependency may have its own dependencies which then will be processed.
After full list of deps is created (no more dependencies can be found) an install transaction is
prepared and executed.

----

### Transactions

Transactions are files describing actions that are taken by PAKE.
There are several types of transactions that are created and executed by PAKE.

Why use a meta language for transaction if they are not too difficult to hardcode?  
There are several good things about them:  

* Using transactions allow for more flexibility (e.g. creating non-standard transactions and
easy expansion if transaction feature-set).  

* Transactions can be cached and executed later - this means that you can manage your software 
even while being disconnected from the Net. Transactions that can be commited in the scope
of your current network will in such situation created and dumped to `.transaction` files in
`~/.pakenode/db/transactions/cached/` directory. When a connection becomes available you can
simply tell PAKE to load and commit previously stored transaction and it will do it.  

* Transactions based on editable text-files can be crafted by humans. This means that you do not
have to rely on PAKE's built-in functionality for doing different things but you can write your own
transaction and tell PAKE to execute it.

&nbsp;

#### 1. High level transactions

These transactions are created when PAKE is *downloading and installing* packages and
can be immediately executed or stored in `~/.pakenode/db/transactions/prepared`.

Advanced users are given a tool for fine-grained control of PAKE because they can write
transaction manually.

Syntax and rules of PAKE transaction files make it very easy to create new keywords and thus
expanding range of things transactions are capable of.

&nbsp;

#### 1.1 Parsing high-level transactions

PAKE transaction files are line-oriented.
Each physical line is also logical line.
Comments are lines that start with `#` character.
Comments MUST NOT appear after a statement.

Syntax error should be raised when line contains less than two items.

Parsing procedure:

0. open a file for reading,
0. read lines of the file,
0. strip whitespace from the ends of each line,
0. purge empty lines,
0. purge every line which first character is `#` (comments),
0. tokenize any lines left,

Each logical line is then translated into a statement (in form of a dictionary) understood by runner which
iterates through the translated file statement by statement (transactions are completely procedural) executing
each request.

&nbsp;

#### 1.1.1 Statements and syntax

All statements follow this syntax:

    KEYWORD package_name

Package name must appear immediately after main keyword (before any optional arguments).
Context in which it is used (whether it points to remote/local or (not)installed
package) depends on the keyword.

Keywords **MUST** be written in all capitals. Transactions are case-sensitive.  
All arguments (sub-keywords) **MUST** be written in capitals.  
All keywords and arguments take a target of some kind (package name, version string, URL etc.).

----

#### 1.2 List of all available statements

Here are listed all statements that are understood by PAKE interpreter and
are available for developers.
The list will be expanding to cover not only package management but also more
aspects of PAKE functionality.

Quick list:

* `FETCH` - fetch package from the net and save it to the `~/.pakenode/cached/`
* `INSTALL` - install previously cached package
* `REMOVE` - remove a package

&nbsp;

#### 1.2.1 `FETCH`

**Meaning**: *Fetch package named `foo` from the network*

**Description**:
*Download package named `foo` from the network and save it in `~/.pakenode/cached/` directory.
Downloaded archive is named `{name}-{version}.tar.xz`*

Basic syntax:

    FETCH foo

However, this relies on package search feature which can find two packages with the same name (which is not a problem with
manual installs as humans can read the descriptions) what can lead to conflicts.  
Also, this means that PAKE must resolve both the origin of the package and find newest version of it.

Faster and more secure way to define such transaction is to set an origin to download from:

    FETCH foo FROM http://pake.example.com

this will eliminate possible name conflicts. When using above statements most recent version of the software
if fetched. It is possible to set a version to fetch using this syntax:

    FETCH foo VERSION 0.0.1 FROM http://pake.example.com

If the specified version cannot be fetched the transaction will fail.

&nbsp;

#### 1.2.2 `INSTALL`

**Meaning**: *Install package named `foo` in `site-packages` directory of my Python installation*

**Description**:
*Take package named `foo` from `~/.pakenode/cached/` directory and extract it to `~/.pakenode/installing/` directory.
Then, execute `install.fsrl` which contains installation instructions.*

Basic syntax:

    INSTALL foo

If no build can be found transaction will fail and PAKE will exit.
If more than one build is found latest version is installed.
It is possible to use extended form of `INSTALL` statement:

    INSTALL foo VERSION 0.0.1

which will try to install specified version of the package. If this version cannot be found transaction will fail.

&nbsp;

#### 1.2.3 `REMOVE`

**Meaning**: *Remove package named `foo` from `site-packages` of my Pyhton installation.*

**Description**:
*Remove the package named `foo` by executing removal procedure described in `~/.pakenode/db/transactions/pkgs/:name/remove.fsrl` file.*

Basic syntax:

    REMOVE foo

If such file cannot be found transaction will fail.

> Should PAKE warn about missing `remove.fsrl` files during installation process?
> What should be done if such file cannot be found?

&nbsp;

#### 1.2.4 `UPDATE`

**Meaning**: *Update package named `foo`.*

**Description**:
*Remove old version of package named `foo` (check: `REMOVE`) and install newest version (check: `INSTALL`).*

Basic syntax:

    UPDATE foo

"compiles" to two statements:

    REMOVE foo
    INSTALL foo

Currently, PAKE does not contain any mechanism specifically designed to handle updates other than
"*remove old/install new*" version of the specified software package.

However, in future, such mechanism may be implemented. If it will turn out to be so, statements for updates will
be contained in `update.fsrl` file. Main point against implementing such mechanism is that FSRL language
used to handle low level transactions does not contain flow-control statements which means it would be hard to
write updates that would work well with majority of versions.

On the contrary, remove/install mechanism will handle everything gracefully since `remove.fsrl`  and
`install.fsrl` are always tailored to the specific versions of the software (`remove.fsrl` is stored in
local database so it always refers to the version currently installed and `install.fsrl` is taken from the release
build of package being installed at the given moment which means it was written with this specific version in mind).

&nbsp;

#### 1.3 PAKE generated transactions

Transactions generated by PAKE are generated already in the middle-form understood by interpreter so
PAKE does not create the source code when it does not have to.
When stored transactions are encoded as JSON files.

#### 2. Low level transactions

Low level transactions manage software installation, update and removal processes and
are written by developers who use PAKE system to distribute their software.

FSRL (*Filesystem Requests Language*) is used for writing low-level transactions.
Information about its syntax and features can be found in [GitHub repository](https://github.com/marekjm/pyfsrl) of
PyFSRL project which is a reference implementation of the FSRL language.


#### 2.1 Installing - `install.fsrl`

These transactions are contined in `install.fsrl` files which contain
FSRL statements that must be performed to install the software.

These transactions are executed by PAKE high-level transaction statement `INSTALL`.

#### 2.2 Removing - `remove.fsrl`

Directives for these transactions are contained in `remove.fsrl` file in every
release build. This file (for installed version of the software) is stored in local PAKE database to remove
the need to extract each build archive to obtain remove transaction statements.

These transactions are exectuted by PAKE high-level transaction statement `REMOVE`.

#### 2.3 Updating - `update.fsrl`

These transactions are contained in `update.fsrl` file in every release build but
are **not** executed.

Updating is done in two steps: removing currently installed version and installing new one.
This is triggered by PAKE high-level statement `UPDATE`.

----

### Security

Security is provided by digital signing of packages.
In order to use PAKE each user must have a PGP (GPG) key which will be used to sign packages.

* imported keys are not sent to the net,
* user's private key is not sent to the net,
* user's public key is sent to the net (people must be able to import it),
* build signatures are sent to the net,
* `nests.json` is not sent to the net, generated `packages.json` is sent,
* `pushers.json` is not sent to the net, generated `mirrors.json` is sent.

----

&nbsp;

**Copyright 2013 (c) Marek Marecki**
