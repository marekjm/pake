## Networking and data distribution

0.  management of aliens should be moved to `network` part of backend before creating a set of requests in transaction runner,

----

## Scripting (transactions) interface

Scripting interface should support only features required for transaction-system inside PAKE and
nothing more.

Features to be implemented:

0.  variable declarations - `var foo;`,
0.  variable definitions - `var foo = "foo"`;
0.  constants - `const foo = "foo";`,
0.  referencing variables and constants,
0.  function declarations (but not definitions),
0.  default parameter in function declarations,
0.  function calls - `foo(0)`,
0.  named and unnamed parameters in function calls,
0.  classes to contain functions, variables and constants,
0.  namespaces (classes?) to enable such function calls as `pake.node.init()`,

Features **not to** be implemented:

0.  `if` and `else` flow-controls,
0.  loops (be it `for` or `while`),
0.  `switch` statement,
0.  math-like expressions (addition, multiplication etc.),



The execution may be stack oriented (easiest way to do it).

```
CODE: foo.bar.baz(0, y=1, z=2);

STACK:

    variable { name = undefined, value = 0 };
    variable { name = "y", value = 1 };
    variable { name = "z", value = 2 };
    call { name = "foo.bar.baz", number_of_parameters = 3 };
```

Here, compilet sees `CODE` and creates such situation of the `STACK`:

0.  take all variables between parentheses `(...)` and place them on stack,
0.  variables are separated by a comma,
0.  take name of the function,
0.  check the name in its namespaces for the list of parameters,
0.  set the number of parameters in the call dict,
0.  take the call dict and place it on stack,

Runner would see something like this,

0.  a variable,
0.  a variable,
0.  a variable,
0.  a function call,
0.  take number of parameters,
0.  get all items on stack that are less or equl than n-indexes before the encountered call,
0.  set them as call parameters,
0.  iterate through them assigning values to names (using param-order list from function declaration),
0.  while iterating assign names to any unnamed arguments (using param-order list from function declaration),
0.  crash if a value is assigned twice,
0.  run the function with call-params-dict as local call-stack,
