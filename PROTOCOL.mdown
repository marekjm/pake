## Definitions

* `global repository` - local repository which contains node metadata, subdirectories for projects,
    list of all known nodes etc.,
* `sub-repository` - repository for single project containing its metadata and archieves,
* `node` - global repository uploaded to server,


----

## Repositories

#### Global repository

This repository is uploaded onto the server and acts as a *node*. 
It is created using `pake setup` command.

    ~/.pakenode/
        meta.json
        nodes.json
        packages.json
        installed.json
        
        db/
            *directory to which `packages.json` files from nodes are downloaded*
            
        downloaded/
            *directory to which archieves are downloaded*
            
        installing/
            *directory to which contents of archieves are extracted before installing*
        
        packages/
            foo/
                meta.json
                *this directory reflects contents of `versions/` subdirectory of a project*
                foo-0.0.1.json
                foo-0.0.1.tar.xz
                foo-0.0.2.json
                foo-0.0.2.tar.xz


----


#### Sub-repository

This repository contains one project.
It is created using `pake init`. 

    ./.pake/
        meta.json 
            *this meta contains name of the project e.g. `foo` which is used as a name for subdirectory in $GLOBAL_REPO/packages/,
             is also a meta for newest version*
             
        versions/
            foo-0.0.1.json
            foo-0.0.1.tar.xz
            foo-0.0.2.json
            foo-0.0.2.tar.xz


----


## Setup

#### Node setup

To set up a node you have to own a server on which the node can be uploaded. 
No special environment is needed as in `pake` everything is done locally and 
servers on the Internet are used only for storage.

This requires proper setup from the very beginning.

----

##### Files of the node


###### `meta.json`

Most important file in EVERY node is `meta.json` -- if this cannot be downloaded a node is considered dead to rest of the network. 
If `meta.json` is present but incomplete (which means it does not contains all required keys) node is also considered dead.

Minimal contents of `meta.json` of a *living* node are:

    {
        'author':'Joe Example',
        'contact':'email [at] example [dot] com',
        'url':'http://pake.example.com/',
        'mirrors':[],
    }

`author` key is used to store authors name or nick. 
`contact` is necessary for contacting author is something is wrong with the node. 
`url` is main URL of the node,
`mirrors` is list of URLs for mirrors of the node.

>   **Detail**: if you set up a mirror for your node do not put its URL in `url` field -- leave it in `mirrors`.
>   This way `pake` can determine if it is using a mirror or not.

----

###### `nodes.json`

This file contains a list. Every element of the list is a `meta.json` file for a different node. 
Example `nodes.json` file:

    [
        {
            'author':'Joe Example',
            'contact':'email [at] example [dot] com',
            'url':'http://pake.example.com/',
            'mirrors':[],
        },
        {
            'author':'Bill Przykladsky',
            'contact':'bill [at] przykladsky [dot] net',
            'url':'http://pake.przykladsky.net/',
            'mirrors':['http://pake.przykladsky.com'],
        }
    ]

If the file cannot be downloaded from the node it is assumed that the file is empty list (so the node cannot be used for node discovery).

----

###### `packages.json`

This file contains a list. Every element of the list is a `meta.json` file for a different package.

If the file cannot be downloaded from the node it is assumed that the file is empty list (so the node has no packages of itself). 
Such nodes can be set up by people who are not distributing any content but are providing a *discovery-nodes* for the network -- 
then they should contain as many nodes as possible for they are as valuable as their node lists.

----

###### `installed.json`

Is a list of all packages installed via `pake` (is very similar to `packages.json` in its contents). 
Uploading this file to the net is *optional* because it can be useful for crackers who 
might want to know what stuff do you have installed on your system but at the same time can be used for backups -- 
by reading it `pake` can recreate your environment.


----

##### Files ot the package

This files are placed in sub-repository.

###### `meta.json`

It is the same as in `meta.json` file for the node -- most important file.
If it does not contain required keys the package is considered broken.

Example file:

    {
        'name':'foo',
        'version':'0.0.1',
        'license':'GNU GPL v2+/GNU GPL v3+',
        'url':'http://pake.example.com',
        'dependencies':[],
    }

Every element in `dependencies` is a dict:
    
    {
        'name':'foo',
        'min':'0.3.16', // optional
        'max':'0.5.0', // optional
        'url':'http://pake.example.com/', // optional but SHOULD be present, if is not found pake will try to determine its url
    }

Optional keys are:

*   `author` - if it is not found `pake` will take author of the repository as the author of the package,
*   `keywords` - list of keywords used by search feature; if not found keywords are extracted from `name` and `description`,
*   `description` - description of the package,
*   `module-name` - if different from package name (you are discouraged from designing such packages),

----

###### `foo-0.0.1.tar.xz`

Archieve containg `INSTALL` and `REMOVE` scripts and package files.


----


## Packages

##### Installing

You can search for packages using `pake search keyword...` feature.
Installation is done via `pake install PACKAGE...` command.

>   **Detail:** transactions could be represented `Transaction()` objects,
>   then they can be exported to JSON and stored, repeated, undo-ed and so on,
>   we can even have history of transactions,

    Transaction():
        packages = [{'name':'', 'url':'', 'mirrors':[], 'dependencies':[]}]
        type = ''
        
        commit(): commits the transaction
        resolve(): checks dependencies
        order(): set packages in order of dependencies
        download():
        install(): run `INSTALL` script
        size(): returns size of transaction

Algorythm:

0.  `pake` will determine main url for every package in transaction,
1.  `pake` will try to find mirrors for every pakcage in transaction,
2.  `pake` will list all dependencies required for transaction,
3.  if dependencies cannot be satisfied because of version issues abort with a message informing about it,
4.  if dependencies cannot be satisfied because they were not found in network abort and suggest using repo discovery
    feature,
5.  check if dependencies match set filters (like license, max version or whaterver will be implemented),
5.  repeat steps `0.` through `5.` until all dependencies are satisfied,
6.  inform about all packages installed, size of the download, licenses etc.,
7.  ask for a confirmation,
8.  if user cancelled the transaction - abort,
9.  if not - download all packages,
10. define order of installation,
11. extract first package to `~/.pakenode/installing/`,
12. run `INSTALL` script,
13. clean `~/.pakenode/installing/`,
14. repeat setps `11.` through `13.` for all packages,
15. exit.


----

Protocol version: 0.0.1-alpha.1+20130604
