### Transactions

Transactions are files describing actions that are taken by PAKE.
There are several types of transactions that are created and executed by PAKE.

Why use a meta language for transaction if they are not too difficult to hardcode?  
There are several good things about them:  

* Using transactions allow for more flexibility (e.g. creating non-standard transactions and
easy expansion of transaction feature-set).  

* Transactions can be cached and executed later - this means that you can manage your software 
even while being disconnected from the Net. Transactions that can be commited in the scope
of your current network will in such situation created and dumped to `.transaction` files in
`~/.pakenode/db/transactions/cached/` directory. When a connection becomes available you can
simply tell PAKE to load and commit previously stored transaction and it will do it.  

* Transactions based on editable text-files can be crafted by humans. This means that you do not
have to rely on PAKE's built-in functionality for doing different things but you can write your own
transaction and tell PAKE to execute it.

**NOTICE**: *please keep in mind that functionality described in this part of documentation might never
actually be implemented in PAKE*

----

#### 1. High level transactions

These transactions are created when PAKE is *downloading and installing* packages and
can be immediately executed or stored in `~/.pakenode/db/transactions/prepared`.

> Currently, only package management-related transactions are implemented as I encountered
> a problem: I can make the meta-language very verbose (which wouldn't necessarily be a good
> thing but at the same time wouldn't be absolutely bad) and keep implementation simple. This would
> provide an easily expandable interface and new functionality for scripting could be added
> relatively fast.  
> On the other hand, I can make the language less verbose but then I would have to write more complex
> translator which would be harder to maintain and add new statements and keywords to.
>
> This is the reason why only package management transactions can be written.
> As soon as I get a good idea how to best implement the language I'll write it but
> I don't want to waste my time on something that will be hard to write and have high
> probability of being thrown away.
>
> However, I think I will implement the interfaces in transactions runner so you should
> be able to meta-program PAKE by writing statements in the translated form and
> sending them directly to the runner.

&nbsp;

#### 1.1 Parsing high-level transactions

PAKE transaction files are line-oriented.
Each physical line is also logical line.
Comments are lines that start with `#` character.
Comments MUST NOT appear after a statement.

Syntax error should be raised when line contains less than two items.

Parsing procedure:

0. open a file for reading,
0. read lines of the file,
0. strip whitespace from the ends of each line,
0. purge empty lines,
0. purge every line which first character is `#` (comments),
0. tokenize any lines left,

Each logical line is then translated into a statement (in form of a dictionary) understood by runner which
iterates through the translated file statement by statement (transactions are completely procedural) executing
each request.

&nbsp;

#### 1.1.1 Statements and syntax

All statements follow this syntax:

    MAIN_KEYWORD CONTEXT_KEYWORD "argument" (SUBKEYWORD "argument")*

Keywords **MUST** be written in all capitals. Transactions are case-sensitive.  
All sub-keywords **MUST** be written in capitals.

> Keep in mind the fact that it's *very* likely to change.

----

#### 1.2 List of all available statements

Here are listed all statements that are understood by PAKE interpreter and
are available for developers.
The list will be expanding to cover not only package management but also more
aspects of PAKE functionality.

Quick list:

* `PKG FETCH` - fetch package from the net and save it to the `~/.pakenode/cached/`
* `PKG INSTALL` - install previously cached package
* `PKG REMOVE` - remove a package

&nbsp;

#### 1.2.1 `PKG FETCH`

**Meaning**: *Fetch package named `foo` from the network*

**Description**:
*Download package named `foo` from the network and save it in `~/.pakenode/cached/` directory.
Downloaded archive is named `{name}-{version}.tar.xz`*

Basic syntax:

    PKG FETCH "foo"

However, this relies on package search feature which can find two packages with the same name (which is not a problem with
manual installs as humans can read the descriptions) what can lead to conflicts.  
Also, this means that PAKE must resolve both the origin of the package and find newest version of it.

Faster and more secure way to define such transaction is to set an origin to download from:

    PKG FETCH "foo" FROM "http://pake.example.com"

this will eliminate possible name conflicts. When using above statements most recent version of the software
if fetched. It is possible to set a version to fetch using this syntax:

    PKG FETCH "foo" VERSION "0.0.1" FROM "http://pake.example.com"

If the specified version cannot be fetched the transaction will fail.

&nbsp;

#### 1.2.2 `PKG INSTALL`

**Meaning**: *Install package named `foo` in `site-packages` directory of my Python installation*

**Description**:
*Take package named `foo` from `~/.pakenode/cached/` directory and extract it to `~/.pakenode/installing/` directory.
Then, execute `install.fsrl` which contains installation instructions.*

Basic syntax:

    PKG INSTALL "foo"

If no build can be found transaction will fail and PAKE will exit.
If more than one build is found latest version is installed.
It is possible to use extended form of `INSTALL` statement:

    PKG INSTALL "foo" VERSION "0.0.1"

which will try to install specified version of the package. If this version cannot be found transaction will fail.

&nbsp;

#### 1.2.3 `PKG REMOVE`

**Meaning**: *Remove package named `foo` from `site-packages` of my Pyhton installation.*

**Description**:
*Remove the package named `foo` by executing removal procedure described in `~/.pakenode/db/transactions/pkgs/:name/remove.fsrl` file.*

Basic syntax:

    PKG REMOVE "foo"

If such file cannot be found transaction will fail.

> Should PAKE warn about missing `remove.fsrl` files during installation process?
> What should be done if such file cannot be found?

&nbsp;

#### 1.2.4 `PKG UPDATE`

> This keyword is not implemented.

**Meaning**: *Update package named `foo`.*

**Description**:
*Remove old version of package named `foo` (check: `REMOVE`) and install newest version (check: `INSTALL`).*

Basic syntax:

    PKG UPDATE "foo"

Currently, PAKE does not contain any mechanism specifically designed to handle updates other than
"*remove old/install new*" version of the specified software package.

However, in future, such mechanism may be implemented. If it will turn out to be so, statements for updates will
be contained in `update.fsrl` file. Main point against implementing such mechanism is that FSRL language
used to handle low level transactions does not contain flow-control statements which means it would be hard to
write updates that would work well with majority of versions.

On the contrary, remove/install mechanism will handle everything gracefully since `remove.fsrl`  and
`install.fsrl` are always tailored to the specific versions of the software (`remove.fsrl` is stored in
local database so it always refers to the version currently installed and `install.fsrl` is taken from the release
build of package being installed at the given moment which means it was written with this specific version in mind).

&nbsp;

#### 1.3 PAKE generated transactions

Transactions generated by PAKE are generated already in the middle-form understood by interpreter so
PAKE does not create the source code when it does not have to.
When stored transactions can be encoded either as JSON files or as PAKE meta-language source code.
However, store them as source code only if you want to study how they work - saving transactions in JSON
allows PAKE to execute them later more quickly as no transalation is needed.
Code executing JSON-stored transaction can be written with only three lines.

    
    ifstream = open('/home/user/.pakenode/db/transactions/prepared/123dead456beef.transaction', 'r')
    pake.transactions.runner.Runner(reqs=json.loads(ifstream.read())).finalize().run()
    ifstream.close()


#### 2. Low level transactions

Low level transactions manage software installation, update and removal processes and
are written by developers who use PAKE system to distribute their software.

FSRL (*Filesystem Requests Language*) is used for writing low-level transactions.
Information about its syntax and features can be found in [GitHub repository](https://github.com/marekjm/pyfsrl) of
PyFSRL project which is a reference implementation of the FSRL language.


#### 2.1 Installing - `install.fsrl`

These transactions are contined in `install.fsrl` files which contain
FSRL statements that must be performed to install the software.

These transactions are executed by PAKE high-level transaction statement `INSTALL`.

#### 2.2 Removing - `remove.fsrl`

Directives for these transactions are contained in `remove.fsrl` file in every
release build. This file (for installed version of the software) is stored in local PAKE database to remove
the need to extract each build archive to obtain remove transaction statements.

These transactions are exectuted by PAKE high-level transaction statement `REMOVE`.

#### 2.3 Updating - `update.fsrl`

These transactions are contained in `update.fsrl` file in every release build but
are **not** executed.

Updating is done in two steps: removing currently installed version and installing new one.
This is triggered by PAKE high-level statement `UPDATE`.

----

[Index](./index.mdown)
