## Transaction encoding

Transactions are lists of requests and each request is a dictionary.

----

### Encoded transactions

Transactions can be encoded into two forms: JSON objects and
source code (the source code option is not yet implemented).

----

### JSON-encoded transactions

Properly encoded request looks like this dictionary:

    {'call': 'request.function.name', 'params': {'dict': 'with', 'given': 'parameters'}}


Transaction is a list of requests so encoded transaction will look like this:

    [{'call': 'foo', 'params': {'bar': 'baz'}}]


Even if transaction has only one request it will still be encoded as a list.

----

### Transactions encoded to source code

> This functionality is not yet implemented!

While every user benefits from JSON-encoding of transactions, source-code encoding is intended as a tool for power users and
developers.
It can give insights to inner workings of PAKE and provide fine-grained control over transactions generated by it.
Default transactions commited by PAKE can also be encoded to source code and altered.
This enables developers and power users to heavily influence behaviour PAKE.

Transactions can be even written from scratch and then executed by PAKE.
Command line interface for running transactions is called `pake-runner`.
To execute custom transaction it must be called with name of the transaction as an operand.
For example to execute transaction named *`custom`* command would be:

```
$ pake-runner custom
```

PAKE will then look for a file named `custom.akemetal` in several predefined directories:

*   `.`,
*   `~/.pakenode/transactions/custom`,
*   `/usr/share/pake/transactions/custom`.

After the file is found, it will be translated to intermediate representation (list of dictionaries) and
passed to runner.
Transation can be skipped with `--no-translate`.
Runner will then assume the file is JSON-encoded list and try to load it as such.

----


#### Translating transactions

Translations can be compiled (e.g. when you want to skip translating file very time a transaction is run) with `pake-translate` program.

From source to JSON:

```
$ pake-translate --to-json [--output outfile.json] infile.akemetal
```

From JSON to source code:

```
$ pake-translate --to-source [--output | -o outfile.akemetal] infile.json
```

Assuming that you have a transaction saved in `custom.akemetal` file
with one request function call per line, following commands would result in creating exact copy of
that file in a `custom2.akemetal` file.

```
$ pake-translate --to-json custom.akemetal
$ pake-translate --to-source --output custom2.akemetal custom.json
```

***Manual translation***

Transaction can be translated manually (but what's the point if the compier is available?).

Example:

```
request.function.call(some="param", foo="bar")
```

becomes:

{
    "call": "request.function.call",
    "params": {
        "some": "param",
        "foo": "bar"
    }
}
