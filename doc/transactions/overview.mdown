## Overview

All internal communication between default UI and PAKE backend is done via transactions mechanism implemented in
*runner*.
This provides another layer of separation between UI (client) code and actual PAKE backend.

----

### Transaction-based workflow

Transaction-based approach to communication design is slower than direct calls to exposed public API but
is more flexible and reliable.  
With UIs built around provided set of requests it's easy to extend the available set and
change the backend without worrying about backwards compatibility because
the only code changed is in transactions runner (which is used by clients but the changes are
in backend-side code and ui-side code is left unchanged).

Even if the original runner would get, at some point in the future, rewritten in e.g. C++ all clients
would require little to no changes.


*Schema*:

```
UI --> [generated "compiled" transactions] --> runner --> [API calls] --> backend
```

In the first step UI is called by user and is given some input.

A list of requests (a *transaction*) which are needed to perform the task given by user is then generated by user interface.
Note how transactions can be combined in a different ways to achieve different results.

This generated transaction is then passed to runner (there is no encode/decode step since generated transactions are
already in a "*precompiled*" (i.e. interpretable by runner) form).

Runner iterates over the list of requests and for each one calls the internal API methods required to perform every
request.
